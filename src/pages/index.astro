---
import SWork from '../components/SWork.astro'
import '../styles/global.scss'
---

<html lang="en" class="is-scroll-blocked theme-contrasted">
  <head>
    <meta charset="utf-8" />

    <title>Works Section - Portfolio</title>

    <meta
      name="description"
      content="Interactive works portfolio section with smooth animations." />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />

    <meta name="robots" content="noindex, nofollow" />

    <link
      rel="icon"
      type="image/png"
      href="/icons/favicon-48x48.png"
      sizes="48x48"
    />

    <meta name="theme-color" content="#160000" />
    <meta name="msapplication-navbutton-color" content="#160000" />
    <meta name="apple-mobile-web-app-status-bar-style" content="#160000" />

    <link
      rel="preload"
      href="/fonts/PPEditorialNew-Regular.woff2"
      as="font"
      type="font/woff2"
      crossorigin="anonymous"
    />
    <link
      rel="preload"
      href="/fonts/PPEditorialNew-Ultralight.woff2"
      as="font"
      type="font/woff2"
      crossorigin="anonymous"
    />
    <link
      rel="preload"
      href="/fonts/PPFraktionMono-Regular.woff2"
      as="font"
      type="font/woff2"
      crossorigin="anonymous"
    />
    <link
      rel="preload"
      href="/fonts/PPFraktionMono-Bold.woff2"
      as="font"
      type="font/woff2"
      crossorigin="anonymous"
    />
    <link
      rel="preload"
      href="/fonts/Bigger-Display.woff2"
      as="font"
      type="font/woff2"
      crossorigin="anonymous"
    />
  </head>

  <body>
    <div class="site-wrapper js-site-wrapper" style="opacity: 0;">
      <SWork />
    </div><!-- .site-wrapper -->
  </body>

  <script>
    import Emitter from '../utils/Emitter'
    import Ticker from '../utils/Ticker'

    import { gsap } from 'gsap'
    import { ScrollTrigger } from 'gsap/ScrollTrigger'
    gsap.registerPlugin(ScrollTrigger)

    declare global {
      interface Window {
        safeWidth: number
        safeHeight: number
        maxScrollTop: number
        scrollProgress: number
      }
    }

    class Site {
      timeouts: any = {
        resizeThrottle: null,
      }

      windowWidth: number
      windowHeight: number
      clientWidth: number
      clientHeight: number

      isScrolling: boolean = false

      /**
       * Constructor
       */
      constructor() {
        // OS class
        let os = 'unknown'
        if (navigator.userAgent.indexOf('Win') !== -1) {
          os = 'windows'
        } else if (navigator.userAgent.indexOf('Android') !== -1) {
          os = 'android'
        } else if (navigator.userAgent.indexOf('Mac') !== -1) {
          os = 'mac'
        } else if (navigator.userAgent.indexOf('Linux') !== -1) {
          os = 'linux'
        }
        document.documentElement.classList.add(`is-${os}`)

        // Browser class
        let browser = 'unknown'
        if (navigator.userAgent.indexOf('Firefox') !== -1) {
          browser = 'firefox'
        } else if (navigator.userAgent.indexOf('Chrome') !== -1) {
          browser = 'chrome'
        } else if (navigator.userAgent.indexOf('Safari') !== -1) {
          browser = 'safari'
        }
        document.documentElement.classList.add(`is-${browser}`)

        this.bindEvents()
      }

      /**
       * Initialization
       */
      init() {
        Ticker.init()

        this.onResize()
        Ticker.nextTick(this.intro, this)
      }

      /**
       * Bind events
       */
      bindEvents() {
        window.addEventListener('resize', this.resizeThrottle.bind(this))
        window.addEventListener('scroll', this.onScroll.bind(this), {
          passive: true,
        })

        Emitter.on('updateViewport', this.onResize, this, true)

        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              entry.target.dispatchEvent(
                new CustomEvent('intersect', {
                  detail: { isIntersecting: entry.isIntersecting },
                })
              )

              if (entry.isIntersecting) {
                entry.target.classList.add('is-in-view')
                entry.target.classList.remove(
                  'is-out-of-view',
                  'is-out-of-view-top',
                  'is-out-of-view-bottom'
                )
              } else {
                entry.target.classList.remove('is-in-view')
                entry.target.classList.add('is-out-of-view')

                entry.target.classList.toggle(
                  'is-out-of-view-top',
                  entry.boundingClientRect.top < 0
                )
                entry.target.classList.toggle(
                  'is-out-of-view-bottom',
                  entry.boundingClientRect.top > 0
                )
              }
            })
          },
          {
            threshold: 0,
          }
        )

        document.querySelectorAll('[data-intersect]').forEach((el) => {
          observer.observe(el)
        })

        // Site loaded event
        if (document.readyState === 'complete') {
          this.siteLoaded()
        } else {
          window.addEventListener('load', this.siteLoaded, { once: true })
        }

        this.onScroll()
      }

      /**
       * Set loaded class
       */
      siteLoaded() {
        document.documentElement.classList.add('is-loaded')

        Emitter.emit('siteLoaded')
      }

      /**
       * Resize throttle
       */
      resizeThrottle() {
        clearTimeout(this.timeouts.resizeThrottle)

        this.timeouts.resizeThrottle = setTimeout(() => {
          Ticker.nextTick(this.onResize, this)
        }, 200)
      }

      /**
       * Resize handler
       */
      onResize() {
        const newWidth = window.innerWidth
        let widthChanged = false
        if (this.windowWidth !== newWidth) {
          if (this.windowWidth !== undefined) {
            widthChanged = true
          }

          this.windowWidth = newWidth
          this.clientWidth = document.body.clientWidth
        }

        const newHeight = window.innerHeight
        let heightChanged = false
        if (this.windowHeight !== newHeight) {
          if (this.windowHeight !== undefined) {
            heightChanged = true
          }

          this.windowHeight = newHeight
          this.clientHeight = document.body.clientHeight
        }

        window.safeWidth = newWidth
        window.safeHeight = newHeight

        window.maxScrollTop = document.body.scrollHeight - window.safeHeight

        this.setScrollProgress()

        Emitter.emit('resize', widthChanged, heightChanged)
      }

      /**
       * Scroll handler
       */
      onScroll() {
        this.setScrollProgress()

        Ticker.nextTick(() => {
          Emitter.emit('scroll', window.scrollY)
        })
      }

      /**
       * Set scroll progress
       */
      setScrollProgress() {
        window.scrollProgress = window.scrollY / window.maxScrollTop
      }

      /**
       * Intro
       */
      intro() {
        const wrapper: HTMLElement = document.querySelector('.js-site-wrapper')

        gsap.to(wrapper, {
          opacity: 1,
          duration: 0.3,
          onComplete: () => {
            document.documentElement.classList.remove('is-scroll-blocked')
          },
        })
      }
    }

    const site = new Site()
    site.init()
  </script>
</html>
