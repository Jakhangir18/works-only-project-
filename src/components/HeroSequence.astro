---
const {
  totalFrames = 120,
  startFrame = 1,
  framePath = '/hero-sequence/frame_',
  frameExt = 'jpg',
} = Astro.props
---

<section
  class="hero-sequence"
  data-hero-sequence
  data-total-frames={String(totalFrames)}
  data-start-frame={String(startFrame)}
  data-frame-path={framePath}
  data-frame-ext={frameExt}
>
  <div class="hero-sequence__sticky">
    <canvas id="hero-sequence" class="hero-sequence__canvas" aria-hidden="true"></canvas>
  </div>
</section>

<script>
  class HeroSequence {
    root: HTMLElement
    canvas: HTMLCanvasElement
    ctx: CanvasRenderingContext2D

    totalFrames: number
    startFrame: number
    framePath: string
    frameExt: string

    frameCache: Map<number, HTMLImageElement>
    pendingLoads: Map<number, Promise<HTMLImageElement>>

    currentFrame: number
    rafId: number

    constructor(root: HTMLElement) {
      this.root = root
      this.canvas = root.querySelector('.hero-sequence__canvas')!
      this.ctx = this.canvas.getContext('2d')!

      this.totalFrames = Number(root.dataset.totalFrames || 120)
      this.startFrame = Number(root.dataset.startFrame || 1)
      this.framePath = root.dataset.framePath || '/hero-sequence/frame_'
      this.frameExt = root.dataset.frameExt || 'jpg'

      this.frameCache = new Map()
      this.pendingLoads = new Map()

      this.currentFrame = this.startFrame
      this.rafId = 0

      this.onResize = this.onResize.bind(this)
      this.onScroll = this.onScroll.bind(this)
      this.render = this.render.bind(this)
    }

    init() {
      this.resizeCanvas()
      this.preload(this.startFrame)?.then((img) => this.drawCover(img)).catch(() => {})
      this.preloadBatch(this.startFrame, Math.min(this.startFrame + 24, this.endFrame()))

      window.addEventListener('resize', this.onResize, { passive: true })
      window.addEventListener('scroll', this.onScroll, { passive: true })

      this.render()

      const preloadRest = () => {
        this.preloadBatch(this.startFrame, this.endFrame())
      }

      if ('requestIdleCallback' in window) {
        ;(window as any).requestIdleCallback(preloadRest)
      } else {
        setTimeout(preloadRest, 400)
      }
    }

    endFrame() {
      return this.startFrame + this.totalFrames - 1
    }

    frameUrl(frame: number) {
      const padded = String(frame).padStart(3, '0')
      return `${this.framePath}${padded}.${this.frameExt}`
    }

    preload(frame: number) {
      if (this.frameCache.has(frame)) {
        return Promise.resolve(this.frameCache.get(frame))
      }

      if (this.pendingLoads.has(frame)) {
        return this.pendingLoads.get(frame)
      }

      const promise = new Promise<HTMLImageElement>((resolve, reject) => {
        const image = new Image()
        image.decoding = 'async'
        image.src = this.frameUrl(frame)

        image.onload = () => {
          this.frameCache.set(frame, image)
          this.pendingLoads.delete(frame)
          resolve(image)
        }

        image.onerror = () => {
          this.pendingLoads.delete(frame)
          reject(new Error(`Frame load failed: ${frame}`))
        }
      })

      this.pendingLoads.set(frame, promise)
      return promise
    }

    preloadBatch(from: number, to: number) {
      for (let frame = from; frame <= to; frame++) {
        this.preload(frame)?.catch(() => {})
      }
    }

    resizeCanvas() {
      const dpr = Math.max(1, window.devicePixelRatio || 1)
      const width = window.innerWidth
      const height = window.innerHeight

      this.canvas.width = Math.floor(width * dpr)
      this.canvas.height = Math.floor(height * dpr)
      this.canvas.style.width = `${width}px`
      this.canvas.style.height = `${height}px`

      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0)
      this.ctx.imageSmoothingEnabled = true
      this.ctx.imageSmoothingQuality = 'high'
    }

    getProgress() {
      const rect = this.root.getBoundingClientRect()
      const absoluteTop = window.scrollY + rect.top
      const scrollSpan = Math.max(1, rect.height - window.innerHeight)
      const raw = (window.scrollY - absoluteTop) / scrollSpan

      return Math.min(1, Math.max(0, raw))
    }

    frameByProgress(progress: number) {
      const localIndex = Math.round(progress * (this.totalFrames - 1))
      return this.startFrame + localIndex
    }

    drawCover(image: HTMLImageElement) {
      const width = window.innerWidth
      const height = window.innerHeight

      const sourceWidth = image.naturalWidth || image.width
      const sourceHeight = image.naturalHeight || image.height

      if (!sourceWidth || !sourceHeight) {
        return
      }

      const scale = Math.max(width / sourceWidth, height / sourceHeight)
      const drawWidth = sourceWidth * scale
      const drawHeight = sourceHeight * scale

      const offsetX = (width - drawWidth) * 0.5
      const offsetY = (height - drawHeight) * 0.5

      this.ctx.clearRect(0, 0, width, height)
      this.ctx.drawImage(image, offsetX, offsetY, drawWidth, drawHeight)
    }

    render() {
      this.rafId = 0

      const progress = this.getProgress()
      const frame = this.frameByProgress(progress)

      if (frame === this.currentFrame && this.frameCache.has(frame)) {
        const cachedFrame = this.frameCache.get(frame)
        if (cachedFrame) {
          this.drawCover(cachedFrame)
        }
        return
      }

      this.currentFrame = frame

      this.preload(frame)
        ?.then((img) => {
          if (this.currentFrame === frame) {
            this.drawCover(img)
          }
        })
        .catch(() => {})

      this.preloadBatch(Math.max(this.startFrame, frame - 2), Math.min(this.endFrame(), frame + 2))
    }

    requestRender() {
      if (this.rafId) return
      this.rafId = window.requestAnimationFrame(this.render)
    }

    onResize() {
      this.resizeCanvas()
      this.requestRender()
    }

    onScroll() {
      this.requestRender()
    }
  }

  const mount = () => {
    const root = document.querySelector('[data-hero-sequence]') as HTMLElement | null
    if (!root) return

    const hero = new HeroSequence(root)
    hero.init()
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', mount, { once: true })
  } else {
    mount()
  }
</script>

<style lang="scss">
  .hero-sequence {
    position: relative;
    z-index: 1;
    height: 400vh;

    .hero-sequence__sticky {
      position: sticky;
      top: 0;
      height: 100vh;
      overflow: hidden;
    }

    .hero-sequence__canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  }
</style>
