---
const { className = '' } = Astro.props
---

<div class:list={['dotted-surface', className]} data-dotted-surface></div>

<script>
  import * as THREE from 'three'

  class DottedSurfaceAnimation {
    container: HTMLElement
    scene!: THREE.Scene
    camera!: THREE.PerspectiveCamera
    renderer!: THREE.WebGLRenderer
    points!: THREE.Points
    geometry!: THREE.BufferGeometry
    material!: THREE.PointsMaterial
    animationId: number
    count: number
    
    readonly SEPARATION = 150
    readonly AMOUNTX = 40
    readonly AMOUNTY = 60

    constructor(container: HTMLElement) {
      this.container = container
      this.count = 0
      this.animationId = 0

      this.initScene()
      this.createParticles()
      this.bindEvents()
      this.animate()
    }

    initScene() {
      console.log('DottedSurface: Creating scene...')
      this.scene = new THREE.Scene()
      // Fog disabled for better wave visibility
      // this.scene.fog = new THREE.Fog(0x160000, 2000, 10000)

      this.camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        1,
        10000
      )
      this.camera.position.set(0, 355, 1220)

      this.renderer = new THREE.WebGLRenderer({
        alpha: true,
        antialias: true,
      })
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
      this.renderer.setSize(window.innerWidth, window.innerHeight)
      this.renderer.setClearColor(0x000000, 0)

      this.container.appendChild(this.renderer.domElement)
      console.log('DottedSurface: Canvas appended to container')
    }

    createParticles() {
      const positions: number[] = []
      const colors: number[] = []

      const isDark = document.documentElement.classList.contains('theme-contrasted')

      for (let ix = 0; ix < this.AMOUNTX; ix++) {
        for (let iy = 0; iy < this.AMOUNTY; iy++) {
          const x = ix * this.SEPARATION - (this.AMOUNTX * this.SEPARATION) / 2
          const y = 0
          const z = iy * this.SEPARATION - (this.AMOUNTY * this.SEPARATION) / 2

          positions.push(x, y, z)

          // Pure white for maximum visibility
          colors.push(255, 255, 255)
        }
      }

      this.geometry = new THREE.BufferGeometry()
      this.geometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(positions, 3)
      )
      this.geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3))

      this.material = new THREE.PointsMaterial({
        size: 12,
        vertexColors: true,
        transparent: true,
        opacity: 0.3,
        sizeAttenuation: true,
      })

      this.points = new THREE.Points(this.geometry, this.material)
      this.scene.add(this.points)
      console.log(`DottedSurface: ${this.AMOUNTX * this.AMOUNTY} particles created`)
    }

    animate = () => {
      this.animationId = requestAnimationFrame(this.animate)

      const positionAttribute = this.geometry.attributes.position
      const positions = positionAttribute.array as Float32Array

      let i = 0
      for (let ix = 0; ix < this.AMOUNTX; ix++) {
        for (let iy = 0; iy < this.AMOUNTY; iy++) {
          const index = i * 3

          positions[index + 1] =
            Math.sin((ix + this.count) * 0.3) * 50 +
            Math.sin((iy + this.count) * 0.5) * 50

          i++
        }
      }

      positionAttribute.needsUpdate = true
      this.renderer.render(this.scene, this.camera)
      this.count += 0.03
    }

    handleResize = () => {
      this.camera.aspect = window.innerWidth / window.innerHeight
      this.camera.updateProjectionMatrix()
      this.renderer.setSize(window.innerWidth, window.innerHeight)
    }

    bindEvents() {
      window.addEventListener('resize', this.handleResize, { passive: true })
    }

    destroy() {
      window.removeEventListener('resize', this.handleResize)
      cancelAnimationFrame(this.animationId)

      this.scene.traverse((object: THREE.Object3D) => {
        if (object instanceof THREE.Points) {
          object.geometry.dispose()
          if (Array.isArray(object.material)) {
            object.material.forEach((mat: THREE.Material) => mat.dispose())
          } else {
            object.material.dispose()
          }
        }
      })

      this.renderer.dispose()

      if (this.container && this.renderer.domElement) {
        this.container.removeChild(this.renderer.domElement)
      }
    }
  }

  const mount = () => {
    const container = document.querySelector('[data-dotted-surface]') as HTMLElement
    if (!container) {
      console.warn('DottedSurface container not found')
      return
    }

    console.log('DottedSurface initializing...')
    const animation = new DottedSurfaceAnimation(container)

    return () => {
      animation.destroy()
    }
  }

  // Ensure mount runs after component is in DOM
  if (typeof window !== 'undefined') {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', mount, { once: true })
    } else {
      // DOM already loaded, mount immediately
      setTimeout(mount, 0)
    }
  }
</script>

<style lang="scss">
  .dotted-surface {
    position: absolute;
    inset: 0;
    z-index: 1;
    pointer-events: none;

    :global(canvas) {
      display: block;
      width: 100%;
      height: 100%;
    }
  }
</style>
